# 设计模式222
## 七种设计原则
- 单一职责原则
- 开闭原则
- 里氏替换原则
- 迪米特法则
- 接口隔离原则
- 依赖倒置原则
## 创建者模式
### 1.工厂模式
定义一个创建对象的接口，让其子类决定实例化哪一个工厂类。

为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。
### 2. 抽象工厂模式
抽象工厂是一个中心工厂，创建其他工厂。使用动态代理创建要选择的工厂。
### 3. 创建者模式
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

方法返回创建对象的本身，拼接调用的方法即可。
### 4. 原型模式
使用克隆的方式创建重复对象。
### 5. 单例模式
CAS，双检锁等写法。  这个类只能创建一次，私有化构造方法，调用方法来创建。
## 结构型模式
### 1. 适配器模式
其作用是把原本不兼容的接口，通过适配修改做到统一。

接口适配，属性适配（名称不同，意义相同的可以使用反射）

### 2. 桥接模式
通过将抽象部分与实现部分分离，把多种可匹配的使用进行组合。

A类中含有B类接口，通过构造函数传递B类的实现。

示例：不同的支付方法（wx zfb），不同的支付安全校验(密码，人脸识别，指纹等)。

### 3. 组合模式
组合模式主要解决的是一系列简单逻辑节点或者扩展的复杂逻辑节点.  （如树形结构）

在不同结构的组织下，对于外部的调用是非常简单的。

### 4. 装饰器模式
动态地给一个对象添加一些额外的职责但又不想增加子类。就增加功能来说，装饰器模式相比生成子类更为灵活。

主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
而装饰者模式中的装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

### 5. 外观模式
也叫门面模式，主要解决的是降低调用方的使用接口的复杂逻辑组合。  中间包一层。

比如调用接口时的**白名单前置校验**， 可以使用注解来完成，对于使用来说，只需要简单加一个注解。

编写注解时，需要AOP和反射的知识。

### 6. 享元模式
享元模式，主要在于共享通用对象，减少内存的使用，提升系统的访问效率。

而这部分共享对象通常比较耗费内存或者需要查询大量接口或者使用数据库资源，因此统一抽离作为共享对象使用。

如：数据库连接池、线程池。

### 7. 代理模式
主要学习动态代理的两种实现形式，cglib和jdk自带的proxy。  重点再学习反射，要会写。


## 行为模型
### 1. 责任链模式
类内部有一个字段是本身指向next。


### 2. 命令模式
命令，实现，调用者      三方
面向接口进行开发

### 3. 迭代器模式
实现 Iterable 接口，通过 next 的方式获取集合元素，同时具备对元素的删除等操作。

### 4. 中介者模式


### 5. 备忘录模式


### 6. 观察者模式


### 7. 状态模式


### 8. 策略模式


### 9. 模板模式


### 10. 访问者模式





